{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2023-09-11 09:42:41","folded":true,"id":1,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:43:37","id":4,"linecolor":"ff59c6ff","page":-1,"title":"什么是数据结构","type":7,"uuid":"a4529101eb0e38152f5ade6402b47304"},{"date":"2023-09-11 09:43:45","id":5,"linecolor":"ff59c6ff","page":-1,"title":"基本概念和术语","type":7,"uuid":"47f3dec681973cef2aff1dca54715e63"},{"date":"2023-09-11 09:43:56","id":6,"linecolor":"ff59c6ff","page":-1,"title":"抽象数据类型的表达与实现","type":7,"uuid":"87a2a239ecff08fb466ce3f04727b2c1"},{"date":"2023-09-11 09:44:25","id":7,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:44:32","id":8,"linecolor":"ff59c6ff","page":-1,"title":"算法","type":7,"uuid":"f0481e712d160fe0fb35e8eea2b57752"},{"date":"2023-09-11 09:44:37","id":9,"linecolor":"ff59c6ff","page":-1,"title":"算法设计的要求","type":7,"uuid":"bee2430e6b8fb2d0a6544a4b83034ad6"},{"date":"2023-09-11 09:44:42","id":10,"linecolor":"ff59c6ff","page":-1,"title":"算法效率的度量","type":7,"uuid":"a163748e59a3cf69b09c7d0e992890ed"},{"date":"2023-09-11 09:44:53","id":11,"linecolor":"ff59c6ff","page":-1,"title":"算法的存储空间需求","type":7,"uuid":"999f95cb2e7b55ec2a19ee4d6d9acc90"}],"page":-1,"title":"算法和算法分析","type":7,"uuid":"d46b4b714f6b74d77c4d5e71297441b5"}],"page":-1,"title":"绪论","type":7,"uuid":"dd8e1a45214aa09254af735b23d3e17a"},{"date":"2023-09-11 09:45:13","folded":true,"id":12,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:45:22","id":13,"linecolor":"ff59c6ff","page":-1,"title":"线性表的类型定义","type":7,"uuid":"3049a442a393cbdafefde9aa74d54d65"},{"date":"2023-09-11 09:45:33","id":14,"linecolor":"ff59c6ff","page":-1,"title":"线性表的顺序表示和实现","type":7,"uuid":"d8f6bbeb9a7f69dbed165c612836e88d"},{"date":"2023-09-11 09:54:25","id":15,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:54:39","id":16,"linecolor":"ff59c6ff","page":-1,"title":"线性链表","type":7,"uuid":"eafc8d146e9cd2075bf11c48bffef29b"},{"date":"2023-09-11 09:54:48","id":17,"linecolor":"ff59c6ff","page":-1,"title":"循环链表","type":7,"uuid":"89ab60d31094269cc3a49890f347f1ba"},{"date":"2023-09-11 09:54:53","id":18,"linecolor":"ff59c6ff","page":-1,"title":"双向链表","type":7,"uuid":"2d7ad1f1cb319071926f74cf4297819a"}],"page":-1,"title":"线性表的链式表示和实现","type":7,"uuid":"cbb084bc33efb5a01d1c57ac740c8f18"},{"date":"2023-09-11 09:55:03","id":19,"linecolor":"fff89e02","page":-1,"title":"一元多项式的表示及相加","type":7,"uuid":"d00ebb0a5ff15236861fc55d000a3f5d"}],"page":-1,"title":"线性表","type":7,"uuid":"3025e4ab8054ff1feadb5712acb21b6d"},{"date":"2023-09-11 09:55:23","id":20,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:56:15","id":21,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:56:20","id":22,"linecolor":"ff59c6ff","page":-1,"title":"抽象数据类型栈的定义","type":7,"uuid":"01900391faafd1bd1a076e6a5adbc779"},{"date":"2023-09-11 09:56:33","id":23,"linecolor":"ff59c6ff","page":-1,"title":"栈的表示和实现","type":7,"uuid":"f0bbf397b90e058eb5532e15df8a0f49"}],"page":-1,"title":"栈","type":7,"uuid":"186bb0623dc559e916fd8574c184990b"},{"date":"2023-09-11 09:56:45","id":24,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:57:15","id":25,"linecolor":"ff59c6ff","page":-1,"title":"数值转换","type":7,"uuid":"b5da7e0cad70b2f39140ea0c36115ce4"},{"date":"2023-09-11 09:57:26","id":26,"linecolor":"ff59c6ff","page":-1,"title":"括号匹配的检验","type":7,"uuid":"538e62f23aa44d3c360141dbfe926a7a"},{"date":"2023-09-11 09:57:37","id":27,"linecolor":"fff89e02","page":-1,"title":"行编辑程序","type":7,"uuid":"0be09fe52ce17e9d091438f3573b5c13"},{"date":"2023-09-11 09:57:49","id":28,"linecolor":"ff59c6ff","page":-1,"title":"迷宫求解","type":7,"uuid":"d44af4e5cb8c32e2e03954dd294055df"},{"date":"2023-09-11 09:57:58","id":29,"linecolor":"ff59c6ff","page":-1,"title":"表达式求解","type":7,"uuid":"5a9225c2d95747550329d888eaba370f"}],"page":-1,"title":"栈的应用举例","type":7,"uuid":"8f08c387b93ec3e86d22f79aceaf0686"},{"date":"2023-09-11 09:58:05","id":30,"linecolor":"ff59c6ff","page":-1,"title":"栈与递归的实现","type":7,"uuid":"ad31fcde3bf67d0bcc26beffb1708122"},{"date":"2023-09-11 09:58:29","id":31,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:58:32","id":32,"linecolor":"ff59c6ff","page":-1,"title":"抽象数据类型队列的定义","type":7,"uuid":"47f5110b505ca86fb45a4ffd5b03d644"},{"date":"2023-09-11 09:58:49","id":33,"linecolor":"ff59c6ff","page":-1,"title":"链队列——队列的链式表示和实现","type":7,"uuid":"cbc19259649925e9fc1a9a38cb6109e6"},{"date":"2023-09-11 09:59:12","id":34,"linecolor":"ff59c6ff","page":-1,"title":"循环队列——队列的顺序表示和实现","type":7,"uuid":"099f5cd7c983e5f203cb953ee2e0cae8"}],"page":-1,"title":"队列","type":7,"uuid":"ebc0b08ac05af21eacb9ac871543a9af"},{"date":"2023-09-11 09:59:42","id":35,"linecolor":"fff89e02","page":-1,"title":"离散事件模拟","type":7,"uuid":"541bfb29d95312edb334d7563293bea5"}],"page":-1,"title":"栈和队列","type":7,"uuid":"7e3c8cbc134456dbb04a138743d7c40d"},{"date":"2023-09-11 09:59:52","id":36,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 09:59:57","id":37,"linecolor":"ff59c6ff","page":-1,"title":"串类型的定义","type":7,"uuid":"95d04f4aeacd9a6a0701abf952869d05"},{"date":"2023-09-11 10:00:04","id":38,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:00:21","id":39,"linecolor":"ff59c6ff","page":-1,"title":"定长顺序存储表示","type":7,"uuid":"33f44e0358c587789b69d2f16285ecbf"},{"date":"2023-09-11 10:04:02","id":40,"linecolor":"ff59c6ff","page":-1,"title":"堆分配存储表示","type":7,"uuid":"c385357138820def7c871516939414a2"},{"date":"2023-09-11 10:04:13","id":41,"linecolor":"ff59c6ff","page":-1,"title":"串的块链存储表示","type":7,"uuid":"d6f014bb33f089dfe73d6fea9bf83f24"}],"page":-1,"title":"串的表示和实现","type":7,"uuid":"19a93fa4c0323856e1593b420e77cc6e"},{"date":"2023-09-11 10:04:34","id":42,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:05:45","id":43,"linecolor":"ff59c6ff","page":-1,"title":"求子串位置的定位函数 Index(S,T,pos)","type":7,"uuid":"7f56c5aad45e2c551548c7faa3981cee"},{"date":"2023-09-11 10:07:23","id":44,"linecolor":"ff59c6ff","page":-1,"title":"模式匹配的一种改进算法","type":7,"uuid":"058a54bff6c42ec6f56f98fed84ab551"}],"page":-1,"title":"串的模式匹配算法","type":7,"uuid":"e3d892ddfe9c7bbd9e6a4a8ec72cf833"},{"date":"2023-09-11 10:07:46","id":45,"linecolor":"fff89e02","markups":[{"date":"2023-09-11 10:08:00","id":46,"linecolor":"ff59c6ff","page":-1,"title":"文本编辑","type":7,"uuid":"02203e468db000af390527eb40561d8c"},{"date":"2023-09-11 10:08:06","id":47,"linecolor":"ff59c6ff","page":-1,"title":"建立词索引表","type":7,"uuid":"0edacee29eb533cf6d5263eede8a92a0"}],"page":-1,"title":"串操作应用举例","type":7,"uuid":"79318d9ea9e9fc69cd128139cee3b901"}],"page":-1,"title":"串","type":7,"uuid":"265bc6476c8269866c32a01e3527244c"},{"date":"2023-09-11 10:08:30","folded":false,"id":48,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:08:38","id":49,"linecolor":"ff59c6ff","page":-1,"title":"数组的定义","type":7,"uuid":"4c3a2e37d8940c776bb81df39bf63edc"},{"date":"2023-09-11 10:08:51","id":50,"linecolor":"ff59c6ff","page":-1,"title":"数组的顺序表示和实现","type":7,"uuid":"a2283d70c842d48bde7464d86ff2f91a"},{"date":"2023-09-11 10:09:06","folded":false,"id":51,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:09:18","id":52,"linecolor":"ff59c6ff","page":-1,"title":"特殊矩阵","type":7,"uuid":"c580c9e53b7983e61c49e87ceeb4471e"},{"date":"2023-09-11 10:11:32","id":53,"linecolor":"ff59c6ff","page":-1,"title":"稀疏矩阵","type":7,"uuid":"72227d216ca06417e3fbe62d130ce2f1"}],"page":-1,"title":"矩阵的压缩存储","type":7,"uuid":"f86b56cde96a21a9b2d71546f8c199fc"},{"date":"2023-09-11 10:11:42","id":54,"linecolor":"fff89e02","page":-1,"title":"广义表的定义","type":7,"uuid":"ede6eb4d57d8dda5545006e9742ec947"},{"date":"2023-09-11 10:11:54","id":55,"linecolor":"fff89e02","page":-1,"title":"广义表的存储结构","type":7,"uuid":"f80e38de114c045b7f9ae82ba9517c1a"},{"date":"2023-09-11 10:12:06","id":56,"linecolor":"fff89e02","page":-1,"title":"m 元多项式的表示","type":7,"uuid":"5a3eb25707a81e64a73180cf531d97ac"},{"date":"2023-09-11 10:12:27","id":57,"linecolor":"fff89e02","markups":[{"date":"2023-09-11 10:12:38","id":58,"linecolor":"ff59c6ff","page":-1,"title":"求广义表的深度","type":7,"uuid":"182cd63af9741ab9b92d304d2f0a9fb7"},{"date":"2023-09-11 10:12:47","id":59,"linecolor":"ff59c6ff","page":-1,"title":"复制广义表","type":7,"uuid":"9b5eb4d7f995f1eb7c47182f3296d372"},{"date":"2023-09-11 10:12:53","id":60,"linecolor":"ff59c6ff","page":-1,"title":"建立广义表的存储结构","type":7,"uuid":"c810f3fc4f23b244c5034f66453b47e5"}],"page":-1,"title":"广义表的递归算法","type":7,"uuid":"817cbf2f0b3e7c42d8f7604618c4c9d8"}],"page":-1,"title":"数组和广义表","type":7,"uuid":"f83490f0f92f5f460a70b818bd60fc7d"},{"date":"2023-09-11 10:13:19","folded":false,"id":61,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:13:27","id":62,"linecolor":"ff59c6ff","page":-1,"title":"树的定义和基本术语","type":7,"uuid":"a62c95e42ae4023e7a30d2e41abcb9f8"},{"date":"2023-09-11 10:13:39","id":63,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:13:43","id":64,"linecolor":"ff59c6ff","page":-1,"title":"二叉树的定义","type":7,"uuid":"ffc250c8ba8442175967b4c156679440"},{"date":"2023-09-11 10:13:49","id":65,"linecolor":"ff59c6ff","page":-1,"title":"二叉树的性质","type":7,"uuid":"e6f4dafa1cacee1cf0579bbec4f7a6f1"},{"date":"2023-09-11 10:13:59","id":66,"linecolor":"ff59c6ff","page":-1,"title":"二叉树的存储结构","type":7,"uuid":"2853ce15fbdcdb859e1d14e7e2272310"}],"page":-1,"title":"二叉树","type":7,"uuid":"4ddf1d1f6f09fd6dff3ee23f76ccad6d"},{"date":"2023-09-11 10:14:10","id":67,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:14:30","id":68,"linecolor":"ff59c6ff","page":-1,"title":"遍历二叉树","type":7,"uuid":"6e407af856be99228c2fe20162c6e43d"},{"date":"2023-09-11 10:14:35","id":69,"linecolor":"ff59c6ff","page":-1,"title":"线索二叉树","type":7,"uuid":"d37cb089b99c4f50563a4ab5ceafbc85"}],"page":-1,"title":"遍历二叉树和线索二叉树","type":7,"uuid":"9529b2acb1b1d8cf8ca2f077cb9bfdef"},{"date":"2023-09-11 10:14:45","id":70,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:14:52","id":71,"linecolor":"ff59c6ff","page":-1,"title":"树的存储结构","type":7,"uuid":"bdda6fad280c6a1efdec5012a1746f06"},{"date":"2023-09-11 10:15:08","id":72,"linecolor":"ff59c6ff","page":-1,"title":"森林与二叉树的转换","type":7,"uuid":"fbb13f2465385cdda74f731cf0b64ffe"},{"date":"2023-09-11 10:15:18","id":73,"linecolor":"ff59c6ff","page":-1,"title":"树和森林的遍历","type":7,"uuid":"ca1f21b0d3a1c49219b0fca5bfd4a230"}],"page":-1,"title":"树和森林","type":7,"uuid":"de30ad07475039076e2273cc322cd98c"},{"date":"2023-09-11 10:15:29","id":74,"linecolor":"ff59c6ff","page":-1,"title":"树与等价问题","type":7,"uuid":"c7a787f1e5f176222628ebfc31ba9bfd"},{"date":"2023-09-11 10:15:45","id":76,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:16:07","id":77,"linecolor":"ff59c6ff","page":-1,"title":"最优二叉树（赫夫曼树）","type":7,"uuid":"d634090cb174ad3e74c444f05d961986"},{"date":"2023-09-11 10:16:30","id":78,"linecolor":"ff59c6ff","page":-1,"title":"赫夫曼编码","type":7,"uuid":"20cf830ce555d2accee2b6aaab492af3"}],"page":-1,"title":"赫夫曼树及其应用","type":7,"uuid":"3098ed0a1d72512b5abfb4a7ec1aacce"},{"content":"这个809笔记有（经典算法应用章节），但是王道没有","date":"2023-09-11 10:16:55","id":79,"linecolor":"ff59c6ff","page":-1,"title":"回溯法与树的遍历","type":7,"uuid":"bb50f27fffd6acf0f6a1d525042ebc81"},{"date":"2023-09-11 10:17:19","id":80,"linecolor":"ff59c6ff","page":-1,"title":"树的计数","type":7,"uuid":"bda513be08e299dc3c11a7576d6a3315"}],"page":-1,"title":"树和二叉树","type":7,"uuid":"e3854c38e84ba0399536605b25578c4d"},{"date":"2023-09-11 10:17:28","folded":false,"id":81,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:17:38","id":82,"linecolor":"ff59c6ff","page":-1,"title":"图的定义和术语","type":7,"uuid":"5071e4902b4c74d55bd1c516bfb0ef77"},{"date":"2023-09-11 10:17:51","id":83,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:18:00","id":84,"linecolor":"ff59c6ff","page":-1,"title":"数组表示法","type":7,"uuid":"45f2fd80b410e69bc76323e80d997730"},{"date":"2023-09-11 10:18:06","id":85,"linecolor":"ff59c6ff","page":-1,"title":"邻接表","type":7,"uuid":"7e757b8719a1a6bd1cf5248150e16cd1"},{"date":"2023-09-11 10:18:16","id":86,"linecolor":"ff59c6ff","page":-1,"title":"十字链表","type":7,"uuid":"442fb864c382f88d29c4ea5d883cb1b9"},{"date":"2023-09-11 10:18:24","id":87,"linecolor":"ff59c6ff","page":-1,"title":"邻接多重表","type":7,"uuid":"4131ac03eb8d636cfa7d4df53acf1e84"}],"page":-1,"title":"图的存储结构","type":7,"uuid":"9f30e53ecd35a3cfd9819e58f66b78a4"},{"date":"2023-09-11 10:18:33","id":88,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:18:38","id":89,"linecolor":"ff59c6ff","page":-1,"title":"深度优先搜索","type":7,"uuid":"83551c616227f5102e2a01941794ffa1"},{"date":"2023-09-11 10:18:55","id":90,"linecolor":"ff59c6ff","page":-1,"title":"广度优先搜索","type":7,"uuid":"5b38ef7b2924c975b60cb8def78ac441"}],"page":-1,"title":"图的遍历","type":7,"uuid":"3719e051403eea3f8d9e485cca89912d"},{"date":"2023-09-11 10:19:07","id":91,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:19:16","id":92,"linecolor":"ff59c6ff","page":-1,"title":"无向图的连通分量和生成树","type":7,"uuid":"65a7ae536e66d68c6423a3a6a89e8998"},{"date":"2023-09-11 10:19:29","id":93,"linecolor":"ff59c6ff","page":-1,"title":"有向图的强连通分量","type":7,"uuid":"f257720c116482b2de6f7f00aa842ff0"},{"date":"2023-09-11 10:19:50","id":94,"linecolor":"ff59c6ff","page":-1,"title":"最小生成树","type":7,"uuid":"b92ed0afeeec9bb0c3af2bda5d209bef"},{"date":"2023-09-11 10:19:57","id":95,"linecolor":"ff59c6ff","page":-1,"title":"关节点和重连通分量","type":7,"uuid":"1449bf8c6ade1e7c44f5d769aae0a180"}],"page":-1,"title":"图的连通性问题","type":7,"uuid":"a5557b628d8790de6485a0007f0eefbf"},{"date":"2023-09-11 10:20:29","id":96,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:20:44","id":97,"linecolor":"ff59c6ff","page":-1,"title":"拓扑排序","type":7,"uuid":"62662dfc0840244b48670e110fdc5050"},{"date":"2023-09-11 10:20:51","id":98,"linecolor":"ff59c6ff","page":-1,"title":"关键路径","type":7,"uuid":"e8c4c03e541af57b0d9686ff50ba257e"}],"page":-1,"title":"有向无环图及其应用","type":7,"uuid":"3a7cbbb4076d1a2d31f5c2211f610fda"},{"date":"2023-09-11 10:21:03","id":99,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:21:16","id":100,"linecolor":"ff59c6ff","page":-1,"title":"从某个源点到其余各顶点的最短路径","type":7,"uuid":"2817864064a9fc1dbf111de4db913f1b"},{"date":"2023-09-11 10:21:33","id":101,"linecolor":"ff59c6ff","page":-1,"title":"每一对顶点之间的最短路径","type":7,"uuid":"57fb9013db464e258f4e9624eda396d6"}],"page":-1,"title":"最短路径","type":7,"uuid":"ba784931688ad60bb7db1c269f377de5"}],"page":-1,"title":"图","type":7,"uuid":"9d8597e1b0b029a9924a450dcf23958d"},{"date":"2023-09-11 10:22:10","folded":false,"id":102,"linecolor":"fff89e02","markups":[{"date":"2023-09-11 10:22:22","id":103,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 16:30:59","docid":1,"fillcolor":"ffffed99","id":165,"originaltext":"动态存储管理的基本问题是系统如何应用户提出的“请求“分配内存？又如何回收那些用户不再使用而“释放”的内存，以备新的“请求“产生时重新进行分配","page":202,"textblocks":[{"first":[48.159000396728516,443.7569580078125,10.255001068115234,8.6400146484375],"last":[347.5349426269531,459.3569641113281,10.00799560546875,8.6400146484375],"length":71,"rects":[[48.159000396728516,443.7569580078125,379.435115814209,8.6400146484375],[27.27899932861328,459.3569641113281,330.2639389038086,8.6400146484375]],"start":630,"text":"动态存储管理的基本问题是系统如何应用户提出的“请求“分配内存？又如何回收那\n些用户不再使用而“释放”的内存，以备新的“请求“产生时重新进行分配"}],"type":5,"uuid":"50ba3075fd85849db8f9eff3102aa625"},{"date":"2023-09-11 16:39:26","docid":1,"fillcolor":"ffffed99","id":166,"markups":[{"date":"2023-09-11 17:02:42","docid":1,"id":178,"imgfile":"94b9197b72d70b4a59c3ac4e3cd86267.png","linecolor":"ff60bb46","linewidth":4,"page":203,"rect":[142.79999574422848,65.39999805092818,370.7999889492992,179.39999465346352],"type":2,"uuid":"9524e2bbbb7a6df74b0c24df0a18cf1b"}],"originaltext":"在系统运行的初期，整个内存区基本上分隔成两大部分：低地址区包含若干占用块；高地址区（即分配后的剩余部分）是一个“空闲块＂","page":202,"textblocks":[{"first":[57.65699768066406,600.7169799804688,9.96600341796875,8.6400146484375],"last":[240.8263702392578,616.0769653320312,9.706695556640625,8.8800048828125],"length":61,"rects":[[57.65699768066406,600.7169799804688,368.7421112060547,8.6400146484375],[27.27899932861328,616.0769653320312,223.25406646728516,8.8800048828125]],"start":1004,"text":"在系统运行的初期，整个内存区基本上分隔成两大部分：低地址区包含若干占用块；\n高地址区（即分配后的剩余部分）是一个“空闲块＂"}],"type":5,"uuid":"c50a0cc637009a5c69fbd4fb8cba6ee2"}],"page":-1,"title":"概述","type":7,"uuid":"2c6fd4221a755a684c89e97d90bb5981"},{"date":"2023-09-11 10:22:27","folded":true,"id":104,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 16:43:10","docid":1,"fillcolor":"ffffed99","id":167,"markups":[{"date":"2023-09-11 16:47:49","docid":1,"id":168,"imgfile":"ecfe907c55bc47feb9543cddaff6fb77.png","leftbottomcorner":[147.59999560117734,443.0999867945913],"linecolor":"ff60bb46","linewidth":4,"page":203,"rect":[147.59999560117734,368.3999890208247,382.49998860061197,443.0999867945913],"rightbottomcorner":[382.49998860061197,443.0999867945913],"type":2,"uuid":"7363d61e6d3d87acf537491f21a7f43e"},{"date":"2023-09-11 16:48:11","docid":1,"id":169,"imgfile":"f882ecb881cc8fb0db0392f506127e54.png","linecolor":"ff60bb46","linewidth":4,"markups":[{"date":"2023-09-11 16:49:57","docid":1,"fillcolor":"ffffed99","id":170,"originaltext":"可利用空间表中包含所有可分配的空闲块，每一块是链表中的一个结点。","page":204,"textblocks":[{"first":[94.77928924560547,158.76385498046875,10.284698486328125,8.66009521484375],"last":[413.0874328613281,158.76385498046875,10.284698486328125,8.66009521484375],"length":32,"rects":[[94.77928924560547,158.76385498046875,328.5928421020508,8.66009521484375]],"start":120,"text":"可利用空间表中包含所有可分配的空闲块，每一块是链表中的一个结点。"}],"type":5,"uuid":"18d9d894b17d5a2ff73daba7ffdfb4cf"},{"date":"2023-09-11 16:50:51","docid":1,"fillcolor":"ffffed99","id":171,"originaltext":"当用户请求分配时，系统从可利用空间表中删除一个结点分配之，当用户释放其所占内存时，系统即回收并将它插入到可利用空间表中。","page":204,"textblocks":[{"first":[23.069299697875977,174.39385986328125,10.299699783325195,8.66009521484375],"last":[223.3793182373047,190.00537109375,10.042694091796875,8.65960693359375],"length":61,"rects":[[23.069299697875977,174.39385986328125,401.0535640716553,8.66009521484375],[22.859298706054688,190.00537109375,210.56271362304688,8.65960693359375]],"start":153,"text":"当用户请求分配时，系统从可利用空间表中删除一个结点分配之，当用户释放其所占内存\n时，系统即回收并将它插入到可利用空间表中。"}],"type":5,"uuid":"3e89ef22240efadda881a096ca209829"},{"date":"2023-09-11 16:51:43","id":172,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 16:57:24","docid":1,"fillcolor":"ffffed99","id":173,"markups":[{"date":"2023-09-11 16:57:50","docid":1,"fillcolor":"ffffed99","id":174,"originaltext":"在系统开始运行时将归它使用的内存区按所需大小分割成若干大小相同的块，然后用指针链接成一个可利用空间表。由于表中结点大小相同，则分配时无需查找，只要将第一个结点分配给用户即可，同样，当用户释放内存时，系统只要将用户释放的空闲块插入在表头即可","page":204,"textblocks":[{"first":[86.23229217529297,237.0343780517578,10.563697814941406,8.660598754882812],"last":[107.3707046508789,284.55438232421875,10.557296752929688,8.42059326171875],"length":122,"rects":[[86.23229217529297,237.0343780517578,337.5206069946289,8.660598754882812],[22.26129913330078,252.87586975097656,400.81993865966797,8.660110473632812],[23.012298583984375,268.71484375,400.5855712890625,8.660125732421875],[23.042699813842773,284.55438232421875,94.88530158996582,8.42059326171875]],"start":310,"text":"在系统开始运行时将归它使用的内存区按所需大小分割成若干大小相同的\n块，然后用指针链接成一个可利用空间表。由于表中结点大小相同，则分配时无需查找，\n只要将第一个结点分配给用户即可，同样，当用户释放内存时，系统只要将用户释放的空\n闲块插入在表头即可"}],"type":5,"uuid":"d12a7d53d32b50be133aec910754c1d1"},{"date":"2023-09-11 16:58:18","docid":1,"fillcolor":"ffffed99","id":175,"originaltext":"这种情况下的可利用空间表实质上是一个链栈。","page":204,"textblocks":[{"first":[160.07569885253906,284.55438232421875,10.557296752929688,8.42059326171875],"last":[370.8958740234375,284.55438232421875,10.55731201171875,8.42059326171875],"length":21,"rects":[[160.07569885253906,284.55438232421875,221.3774871826172,8.42059326171875]],"start":436,"text":"这种情况下的可利用空间表实质上是一个链栈。"}],"type":5,"uuid":"b3066647f377d3a5511ff6d63ef0dffd"}],"originaltext":"系统运行期间所有用户请求分配的存储量大小相同。","page":204,"textblocks":[{"first":[106.7682876586914,221.1643829345703,10.589698791503906,8.660598754882812],"last":[339.374267578125,221.1643829345703,10.589691162109375,8.660598754882812],"length":23,"rects":[[106.7682876586914,221.1643829345703,243.19567108154297,8.660598754882812]],"start":273,"text":"系统运行期间所有用户请求分配的存储量大小相同。"}],"type":5,"uuid":"ef3780dbd36eb6eaa904673721b3ad1a"},{"date":"2023-09-11 16:59:40","docid":1,"fillcolor":"ffffed99","id":176,"markups":[{"date":"2023-09-11 17:00:10","docid":1,"fillcolor":"ffffed99","id":177,"markups":[{"content":"type取值是确定的几个值","date":"2023-09-11 19:24:03","docid":1,"id":210,"imgfile":"ef12660dd967a6df894396c707776db5.png","linecolor":"ff60bb46","linewidth":4,"page":205,"rect":[42.5999987304211,89.39999733567245,455.39998642802277,312.8999906748536],"type":2,"uuid":"97eaabc133e5f3786f2027eb08aec8ad"}],"originaltext":"建立若干个可利用空间表，同一链表中的结点大小相同。","page":204,"textblocks":[{"first":[104.96060943603516,328.7258605957031,10.310401916503906,11.06011962890625],"last":[351.8966369628906,328.7258605957031,10.310394287109375,11.06011962890625],"length":25,"rects":[[104.96060943603516,328.7258605957031,257.24642181396484,11.06011962890625]],"start":550,"text":"建立若干个可利用空间表，同一链表中的结点大小相同。"}],"type":5,"uuid":"b3b8fd062119ba36d03d98f0942fd2ea"},{"annotations":[{"content":"拆该怎么拆？9拆不成两个5呀","style":0},{"content":"这不就越拆越细碎吗，最后可能没有大块了","style":0}],"content":"既然要拆节点，那么我认为不同的空间请求的大小也要满足一定要求，比如图中的2、4、8-不过也不一定，8-2=6，6还得继续分割","date":"2023-09-11 18:15:07","docid":1,"fillcolor":"ffffed99","id":179,"markups":[{"annotations":[{"content":"这些小的区域都是非连续的吗？并不是，很多小的都可以组成连续的区域，如下图","style":0},{"content":"605a06fadfd9488b850ca7ae21259965.json","style":2}],"content":"<body style=\" font-family:'Microsoft YaHei UI Light'; font-size:10pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">因为一般只会拆更大的<span style=\" font-weight:600;\">空闲区域</span>补足小的<span style=\" font-weight:600;\">空闲区域</span>。若没得拆了，其实有很多小的空闲区域可用</p></body>","date":"2023-09-11 18:47:24","docid":1,"fillcolor":"ffffed99","id":180,"markups":[{"date":"2023-09-11 18:47:44","docid":1,"fillcolor":"ffffed99","id":181,"originaltext":"此时若要使系统能继续运行，就必须重新组织内存，即执行“存储紧缩＂的操作","page":204,"textblocks":[{"first":[122.85830688476562,550.7273559570312,10.042694091796875,8.65960693359375],"last":[63.99979782104492,566.0758666992188,10.30019760131836,8.90008544921875],"length":36,"rects":[[122.85830688476562,550.7273559570312,300.7967224121094,8.65960693359375],[22.867799758911133,566.0758666992188,51.43219566345215,8.90008544921875]],"start":1133,"text":"此时若要使系统能继续运行，就必须重新组织内存，即执行“存储紧\n缩＂的操作"}],"title":"处理太多碎空间","type":5,"uuid":"c17f84d7a2164667b293955f97ef40b4"}],"originaltext":"一个特殊的问题要处理1即当结点与请求相符的链表和结点更大的链表均为空时，分配不能进行，而实际上内存空间并不一定不存在所需大小的连续空间，只是由于在系统运行过程中，频繁出现小块的分配和回收，使得大结点链表中的空闲块被分隔成小块后插入在小结点的链表中，","page":204,"textblocks":[{"first":[53.965301513671875,503.1668395996094,10.502700805664062,8.660125732421875],"last":[112.83230590820312,550.7273559570312,10.042701721191406,8.65960693359375],"length":127,"rects":[[53.965301513671875,503.1668395996094,368.8988952636719,8.660125732421875],[22.77680015563965,519.0458984375,401.0540714263916,8.90008544921875],[22.570959091186523,534.87939453125,401.0540714263916,8.90008544921875],[22.598299026489258,550.7273559570312,100.27670860290527,8.65960693359375]],"start":1006,"text":"一个特殊的问题要处理1即当结点与请求相符的链表和结点更大的链表均为空时，\n分配不能进行，而实际上内存空间并不一定不存在所需大小的连续空间，只是由于在系统\n运行过程中，频繁出现小块的分配和回收，使得大结点链表中的空闲块被分隔成小块后插\n入在小结点的链表中，"}],"title":"似乎是拆得太多了","type":5,"uuid":"d93ac65bd40b55870de2afbb020997ff"}],"originaltext":"此时的分配和回收的方法在很大程度上和第一种情况类似，只是当结点大小和请求分配的量相同的链表为空时，需查询结点较大的链表，并从中取出一个结点，将其中一部分内存分配给用户，而将剩余部分插入到相应大小的链表中。回收时，也只要将释放的空闲块插人到相应大小的链表的表头中去即可。","page":204,"tagids":["8923a931da52f88c14cf9723953cc8be"],"textblocks":[{"first":[146.74729919433594,440.7291564941406,10.64068603515625,8.66082763671875],"last":[320.40087890625,487.6058654785156,10.2822265625,8.900115966796875],"length":137,"rects":[[146.74729919433594,440.7291564941406,276.2405242919922,8.66082763671875],[23.13629913330078,456.40496826171875,399.8449020385742,8.660003662109375],[22.686298370361328,472.005859375,401.0535697937012,8.660125732421875],[22.71579933166504,487.6058654785156,307.96730613708496,8.900115966796875]],"start":856,"text":"此时的分配和回收的方法在很大程度上和第一种情况类似，\n只是当结点大小和请求分配的量相同的链表为空时，需查询结点较大的链表，并从中取出\n一个结点，将其中一部分内存分配给用户，而将剩余部分插入到相应大小的链表中。回收\n时，也只要将释放的空闲块插人到相应大小的链表的表头中去即可。"}],"title":"拆大补小","type":5,"uuid":"16aff8017c5e2c801d7e58ecbc5ea360"}],"originaltext":"系统运行期间用户请求分配的存储量有若干种大小的规格。","page":204,"textblocks":[{"first":[106.58130645751953,315.71435546875,10.5697021484375,8.660614013671875],"last":[370.4063415527344,315.71435546875,10.5697021484375,8.660614013671875],"length":26,"rects":[[106.58130645751953,315.71435546875,274.39473724365234,8.660614013671875]],"start":511,"text":"系统运行期间用户请求分配的存储量有若干种大小的规格。"}],"type":5,"uuid":"df357264bc0f9f164419459532a7f154"},{"date":"2023-09-11 19:15:25","docid":1,"fillcolor":"ffffed99","id":182,"markups":[{"date":"2023-09-11 19:16:56","id":183,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 19:17:22","docid":1,"fillcolor":"ffffed99","id":185,"originaltext":"可利用空间表中的结点即空闲块的大小也是随意的","page":204,"textblocks":[{"first":[54.19529724121094,613.1249389648438,10.268699645996094,8.6600341796875],"last":[269.4873046875,613.1249389648438,10.268707275390625,8.6600341796875],"length":22,"rects":[[54.19529724121094,613.1249389648438,225.5607147216797,8.6600341796875]],"start":1249,"text":"可利用空间表中的结点即空闲块的大小也是随意的"}],"type":5,"uuid":"8c97d31c0712f4dc5daf5fbc86734662"},{"date":"2023-09-11 19:17:05","docid":1,"fillcolor":"ffffed99","id":184,"originaltext":"通常，操作系统中的可利用空间表属这种类型。","page":204,"textblocks":[{"first":[289.9913330078125,613.1249389648438,10.268707275390625,8.6600341796875],"last":[90.2507095336914,629.2063598632812,9.556297302246094,8.41864013671875],"length":22,"rects":[[289.9913330078125,613.1249389648438,133.29287719726562,8.6600341796875],[23.470699310302734,629.2063598632812,76.33630752563477,8.41864013671875]],"start":1272,"text":"通常，操作系统中的可利用空\n间表属这种类型。"}],"type":5,"uuid":"5f519736ea403956ebef3aafb28baebc"}],"page":-1,"title":"特点","type":7,"uuid":"26abf2a187df8bd5f0f74046a42a3e3a"},{"date":"2023-09-11 19:18:44","id":186,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 19:19:16","docid":1,"fillcolor":"ffffed99","group":[{"date":"2023-09-11 19:19:16","docid":1,"fillcolor":"ffffed99","id":188,"originaltext":"","page":205,"textblocks":[{"first":[58.479000091552734,57.117008209228516,10.276996612548828,8.880001068115234],"last":[130.41799926757812,57.117008209228516,10.277008056640625,8.880001068115234],"length":8,"rects":[[58.479000091552734,57.117008209228516,82.21600723266602,8.880001068115234]],"start":0,"text":"整个内存区的结点"}],"type":5,"uuid":"eff4bc8e5f438d46e929c407c093be71"}],"id":187,"originaltext":"系统刚开始工作时，整个内存空间是一个空闲块，即可利用空间表中只有一个大小为整个内存区的结点","page":204,"textblocks":[{"first":[43.900299072265625,644.5249633789062,10.27170181274414,8.6600341796875],"last":[0,0,0,0],"length":80,"rects":[[43.900299072265625,644.5249633789062,379.4518127441406,8.6600341796875],[380.0069580078125,658.8499755859375,38.735382080078125,10.5],[167.8280029296875,693.3516235351562,148.5,9],[167.8280029296875,693.3516235351562,148.5,9]],"start":1295,"text":"系统刚开始工作时，整个内存空间是一个空闲块，即可利用空间表中只有一个大小为\n• 195• \nhttps://www.cnblogs.com/kohler21/\n"}],"type":5,"uuid":"2ec6262d4b07fc168c2bd6104d59e063"},{"annotations":[{"content":"<body style=\" font-family:'Microsoft YaHei UI Light'; font-size:10pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"bookxnotepro://opennote/?nb={91f9d651-022e-4b7f-8ea3-fba77a42f6da}&amp;book=79eed11fdba87a28341a31cc2c858f93&amp;page=203&amp;x=256&amp;y=501&amp;id=169&amp;uuid=ce8bf451a3b8da22344f7cc1bcf26097\"><span style=\" text-decoration: underline; color:#0000ff;\">举例</span></a></p></body>","style":0}],"date":"2023-09-11 19:22:14","docid":1,"fillcolor":"ffffed99","id":208,"markups":[{"date":"2023-09-11 19:28:40","docid":1,"id":211,"imgfile":"5a4df655da4d156faea5e3a5a3d0cc02.png","linecolor":"ff60bb46","linewidth":4,"markups":[{"date":"2023-09-11 19:29:02","docid":1,"fillcolor":"ffffed99","id":212,"originaltext":"结点大小域(size),以指示空闲块的存储量","page":205,"textblocks":[{"first":[169.37399291992188,335.0369873046875,10.125,8.399993896484375],"last":[343.9682922363281,335.0369873046875,9.987701416015625,8.399993896484375],"length":22,"rects":[[169.37399291992188,335.0369873046875,184.58200073242188,8.399993896484375]],"start":270,"text":"结点大小域(size),以指示空闲块的存储量"}],"type":5,"uuid":"00d04d126e2322d30cdabdec1ded3103"},{"date":"2023-09-11 19:29:14","docid":1,"fillcolor":"ffffed99","id":213,"originaltext":"结点中的space域是一个地址连续的内存空间。","page":205,"position":{"x":1942,"y":7413},"textblocks":[{"first":[437.3050231933594,335.0369873046875,10.272003173828125,8.399993896484375],"last":[238.738037109375,350.8769836425781,10.063003540039062,8.160003662109375],"length":24,"rects":[[437.3050231933594,335.0369873046875,20.54400634765625,8.399993896484375],[58.249000549316406,350.8769836425781,190.55204010009766,8.160003662109375]],"start":301,"text":"结点\n中的space域是一个地址连续的内存空间。"}],"type":5,"uuid":"2ebf12186655345be9d4dc7f453bd13d"}],"page":205,"rect":[154.19999540448202,366.5999890744689,361.19998923540146,474.29998586475887],"type":2,"uuid":"65ed1a495938830a5a54f70586cf401d"}],"originaltext":"随着分配和回收的进行，可利用空间表中的结点大小和个数也随之而变","page":205,"textblocks":[{"first":[150.97201538085938,57.117008209228516,10.277008056640625,8.880001068115234],"last":[58.249000549316406,73.19699096679688,9.167999267578125,8.160003662109375],"length":32,"rects":[[150.97201538085938,57.117008209228516,308.31024169921875,8.880001068115234],[58.249000549316406,73.19699096679688,9.167999267578125,8.160003662109375]],"start":9,"text":"随着分配和回收的进行，可利用空间表中的结点大小和个数也随之而\n变"}],"type":5,"uuid":"a3421b25dff1096c048937abb6e2bba0"}],"page":-1,"title":"过程","type":7,"uuid":"c85ca38d6aa5001d4f426500a50bb542"},{"date":"2023-09-11 19:31:19","id":214,"linecolor":"ff59c6ff","markups":[{"annotations":[{"content":"e635c3d22d472814c4e10fca648c8a8b.png","style":1},{"content":"c8f2c3243305f0711c988737fd7459f9.png","style":1}],"date":"2023-09-11 19:31:34","docid":1,"fillcolor":"ffffed99","id":215,"markups":[{"date":"2023-09-11 19:32:06","docid":1,"fillcolor":"ffffed99","id":216,"markups":[{"date":"2023-09-11 19:33:20","docid":1,"fillcolor":"ffffed99","id":217,"markups":[{"date":"2023-09-11 19:33:48","docid":1,"fillcolor":"ffffed99","id":218,"markups":[{"date":"2023-09-11 20:36:58","docid":1,"fillcolor":"ffffed99","id":221,"markups":[{"date":"2023-09-11 20:37:04","docid":1,"fillcolor":"ffffed99","id":222,"originaltext":"回收时，只要将释放的空闲块插人在链表的表头即可","page":205,"textblocks":[{"first":[159.25901794433594,591.3469848632812,10.246002197265625,8.8800048828125],"last":[384.6710510253906,591.3469848632812,10.246002197265625,8.8800048828125],"length":23,"rects":[[159.25901794433594,591.3469848632812,235.6580352783203,8.8800048828125]],"start":643,"text":"回收时，只要将释放的空闲块插人在链表的表头即可"}],"type":5,"uuid":"a643c02001f6cac15bdda7d52dbb8ef7"}],"originaltext":"从表头指针开始查找可利用空间表，将找到的第一个大小不小千n的空闲块的一部分分配给用户","page":205,"textblocks":[{"first":[159.13502502441406,559.9169921875,10.376007080078125,8.4000244140625],"last":[183.63897705078125,575.5069580078125,10.509994506835938,8.6400146484375],"length":43,"rects":[[159.13502502441406,559.9169921875,298.4640655517578,8.4000244140625],[57.51900100708008,575.5069580078125,136.6299705505371,8.6400146484375]],"start":564,"text":"从表头指针开始查找可利用空间表，将找到的第一个大小不小千n\n的空闲块的一部分分配给用户"}],"type":5,"uuid":"ac34fb7742e1992cd9631d991eb93a64"}],"originaltext":"首次拟合法","page":205,"textblocks":[{"first":[96.87899780273438,559.9169921875,10.375999450683594,8.4000244140625],"last":[138.3830108642578,559.9169921875,10.376007080078125,8.4000244140625],"length":5,"rects":[[96.87899780273438,559.9169921875,51.88002014160156,8.4000244140625]],"start":558,"text":"首次拟合法"}],"type":5,"uuid":"b760734c6f6998ce93c2275927a2de0a"},{"date":"2023-09-11 19:33:53","docid":1,"fillcolor":"ffffed99","id":219,"markups":[{"date":"2023-09-11 20:47:47","docid":1,"fillcolor":"ffffed99","id":223,"markups":[{"date":"2023-09-11 20:53:22","docid":1,"fillcolor":"ffffed99","id":224,"markups":[{"annotations":[{"content":"感觉拆开较大的空间后，也需要对剩下的空间进行排序","style":0}],"content":"类似链表在某节点后的插入","date":"2023-09-11 20:54:10","docid":1,"fillcolor":"ffffed99","id":225,"originaltext":"在回收时，必须将释放的空闲块插入到合适的位置上去。","page":206,"textblocks":[{"first":[70.58899688720703,155.80799865722656,9.992897033691406,8.6593017578125],"last":[310.0130310058594,155.80799865722656,9.992919921875,8.6593017578125],"length":25,"rects":[[70.58899688720703,155.80799865722656,249.41695404052734,8.6593017578125]],"start":248,"text":"在回收时，必须将释放的空闲块插入到合适的位置上去。"}],"type":5,"uuid":"45442a881bb2ae5d16fc036b3b5d4975"}],"originaltext":"为了避免每次分配都要扫视整个链表。通常，预先设定可利用空间表的结构按空间块的大小自小至大有序，","page":206,"textblocks":[{"first":[133.54299926757812,123.87799835205078,10.269302368164062,8.899894714355469],"last":[204.42996215820312,139.72900390625,10.182296752929688,8.899703979492188],"length":48,"rects":[[133.54299926757812,123.87799835205078,287.0735168457031,8.899894714355469],[21.459999084472656,139.72900390625,193.15225982666016,8.899703979492188]],"start":174,"text":"为了避免每次分配都要扫视整个链表。通常，预先设定可利用空\n间表的结构按空间块的大小自小至大有序，"}],"title":"需要比较，所以先从小到大排号-维护了一个从小到大的可利用空间表来减少比较次数","type":5,"uuid":"83f9e4c653b359d9b12ecbb85ae6d262"}],"originaltext":"将可利用空间表中一个不小于n且最接近n的空闲块的一部分分配给用户","page":206,"textblocks":[{"first":[124.19700622558594,61.085960388183594,10.513397216796875,8.420303344726562],"last":[52.69099807739258,76.60798645019531,10.5458984375,8.660400390625],"length":33,"rects":[[124.19700622558594,61.085960388183594,297.2712860107422,8.420303344726562],[21.104000091552734,76.60798645019531,42.132896423339844,8.660400390625]],"start":9,"text":"将可利用空间表中一个不小于n且最接近n的空闲块的一部分分\n配给用户"}],"type":5,"uuid":"360af76a357d843a08178d32c9026ffa"}],"originaltext":"最佳拟合法","page":206,"textblocks":[{"first":[61.21500015258789,61.085960388183594,10.51340103149414,8.420303344726562],"last":[103.2030029296875,61.085960388183594,10.513404846191406,8.420303344726562],"length":5,"rects":[[61.21500015258789,61.085960388183594,52.501407623291016,8.420303344726562]],"start":3,"text":"最佳拟合法"}],"type":5,"uuid":"2f223095e600a9352fef96d6f0256b88"},{"date":"2023-09-11 19:33:58","docid":1,"fillcolor":"ffffed99","id":220,"markups":[{"date":"2023-09-11 21:01:27","docid":1,"fillcolor":"ffffed99","id":226,"markups":[{"date":"2023-09-11 21:04:01","docid":1,"fillcolor":"ffffed99","id":227,"markups":[{"date":"2023-09-11 21:04:19","docid":1,"fillcolor":"ffffed99","id":228,"originaltext":"每次分配无需查找，只需从链表中删除第一个结点，并将其中一部分分配给用户，而剩余部分作为一个新的结点插入到可利用空间表的适当位置上去","page":206,"textblocks":[{"first":[245.64105224609375,580.1289672851562,10.25640869140625,8.4197998046875],"last":[102.55500030517578,611.5689697265625,10.238899230957031,8.6597900390625],"length":67,"rects":[[245.64105224609375,580.1289672851562,174.09625244140625,8.4197998046875],[20.09000015258789,595.7279663085938,399.3767967224121,8.6597900390625],[20.77899932861328,611.5689697265625,92.01490020751953,8.6597900390625]],"start":543,"text":"每次分配无需查找，只需从链表中删除\n第一个结点，并将其中一部分分配给用户，而剩余部分作为一个新的结点插入到可利用空\n间表的适当位置上去"}],"title":"只处理第一个节点，并维持从大到小的排序","type":5,"uuid":"afed404eccfd063b4ec5cabcbc0dd440"},{"date":"2023-09-11 21:05:14","docid":1,"fillcolor":"ffffed99","id":229,"originaltext":"在回收时亦需将释放的空闲块插入到链表的适当位置上去","page":206,"textblocks":[{"first":[153.66500854492188,611.5689697265625,10.238906860351562,8.6597900390625],"last":[398.9927978515625,611.5689697265625,10.2388916015625,8.6597900390625],"length":25,"rects":[[153.66500854492188,611.5689697265625,255.56668090820312,8.6597900390625]],"start":614,"text":"在回收时亦需将释放的空闲块插入到链表的适当位置上去"}],"type":5,"uuid":"39e7e3f64afd0fcd10c78cd2033c3e24"}],"originaltext":"可利用空间表的结构应按空闲块的大小自大至小有序","page":206,"textblocks":[{"first":[368.8981018066406,564.6399536132812,10.14239501953125,8.41961669921875],"last":[194.44102478027344,580.1289672851562,10.25640869140625,8.4197998046875],"length":24,"rects":[[368.8981018066406,564.6399536132812,50.64642333984375,8.41961669921875],[20.361000061035156,580.1289672851562,184.33643341064453,8.4197998046875]],"start":515,"text":"可利用空间\n表的结构应按空闲块的大小自大至小有序"}],"type":5,"uuid":"561746a94df0083a5dfd68d70775304e"}],"originaltext":"将可利用空间表中不小于n且是链表中最大的空闲块的一部分分配给用户","page":206,"textblocks":[{"first":[123.93299102783203,173.30360412597656,10.505912780761719,9.376052856445312],"last":[51.847999572753906,189.05235290527344,10.33639907836914,9.175277709960938],"length":33,"rects":[[123.93299102783203,173.30360412597656,297.32308197021484,9.376052856445312],[20.88800048828125,189.05235290527344,41.2963981628418,9.175277709960938]],"start":283,"text":"将可利用空间表中不小于n且是链表中最大的空闲块的一部分分\n配给用户"}],"type":5,"uuid":"55c4d2f9d0416d8fb844ec45765433cf"}],"originaltext":"最差拟合法","page":206,"textblocks":[{"first":[60.999000549316406,173.30360412597656,10.505897521972656,9.376052856445312],"last":[102.95499420166016,173.30360412597656,10.505897521972656,9.376052856445312],"length":5,"rects":[[60.999000549316406,173.30360412597656,52.461891174316406,9.376052856445312]],"start":277,"text":"最差拟合法"}],"type":5,"uuid":"eec236c5c4380aacfb8fae155fb869ab"},{"date":"2023-09-11 21:08:15","id":230,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 21:12:12","id":235,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 21:10:31","docid":1,"fillcolor":"ffffed99","id":231,"markups":[{"date":"2023-09-11 21:11:15","docid":1,"fillcolor":"ffffed99","id":233,"originaltext":"使整个链表趋向于结点大小差别甚远的状态","page":207,"textblocks":[{"first":[280.23895263671875,74.6269760131836,10.55999755859375,8.400001525878906],"last":[68.96299743652344,90.4769515991211,10.277000427246094,8.400001525878906],"length":20,"rects":[[280.23895263671875,74.6269760131836,168.9599609375,8.400001525878906],[48.409000396728516,90.4769515991211,30.830997467041016,8.400001525878906]],"start":61,"text":"使整个链表趋向于结点大小差别甚远\n的状态"}],"type":5,"uuid":"03bde963899dfc5b82f885a43ef70f5e"}],"originaltext":"最佳拟合法适用于请求分配的内存大小范围较广的系统","page":206,"textblocks":[{"first":[230.56805419921875,627.2699584960938,10.532913208007812,8.660400390625],"last":[71.97200012207031,643.0099487304688,10.219902038574219,8.6597900390625],"length":25,"rects":[[230.56805419921875,627.2699584960938,189.30477905273438,8.660400390625],[20.957000732421875,643.0099487304688,61.234901428222656,8.6597900390625]],"start":659,"text":"最佳拟合法适用于请求分配的内存大小范\n围较广的系统"}],"type":5,"uuid":"8ad86e04b54857ef13322a0ac9f9372c"},{"date":"2023-09-11 21:10:52","docid":1,"fillcolor":"ffffed99","id":232,"markups":[{"date":"2023-09-11 21:12:02","docid":1,"fillcolor":"ffffed99","id":234,"originaltext":"使链表中的结点大小趋于均匀","page":207,"textblocks":[{"first":[387.5502014160156,90.4769515991211,10.277008056640625,8.400001525878906],"last":[111.03899383544922,106.31697082519531,10.55999755859375,8.639999389648438],"length":14,"rects":[[387.5502014160156,90.4769515991211,61.66204833984375,8.400001525878906],[47.67900085449219,106.31697082519531,73.91999053955078,8.639999389648438]],"start":111,"text":"使链表中的结\n点大小趋于均匀"}],"type":5,"uuid":"59ccfbbc6c1a8ca2a95d55115c7725e5"}],"originaltext":"最差拟合法适用于请求分配的内存大小范围较窄的系统","page":207,"textblocks":[{"first":[163.8389892578125,106.31697082519531,10.55999755859375,8.639999389648438],"last":[353.9189453125,106.31697082519531,10.55999755859375,8.639999389648438],"length":19,"rects":[[163.8389892578125,106.31697082519531,200.63995361328125,8.639999389648438]],"start":129,"text":"适用千请求分配的内存大小范围较窄的系统"}],"type":5,"uuid":"9e54a2e54bfb2e281b01b161b520f1ba"},{"date":"2023-09-11 21:12:33","docid":1,"fillcolor":"ffffed99","id":236,"originaltext":"首次拟合法介于两者之间，通常适用于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况","page":207,"textblocks":[{"first":[150.6990203857422,122.3869857788086,10.302001953125,8.400001525878906],"last":[160.56199645996094,138.23696899414062,10.283004760742188,8.399993896484375],"length":42,"rects":[[150.6990203857422,122.3869857788086,298.75804138183594,8.400001525878906],[47.44900131225586,138.23696899414062,123.39599990844727,8.399993896484375]],"start":167,"text":"介于两者之间，通常适用于系统事先不掌握运行期间可能出现的请\n求分配和释放的信息的情况"}],"type":5,"uuid":"e7242cd66cea644d5f01fced287feda2"}],"page":-1,"title":"面对场景","type":7,"uuid":"0091e9a8852521f6420d0fc9673df60a"},{"date":"2023-09-11 21:13:12","id":237,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 21:14:35","docid":1,"fillcolor":"ffffed99","id":238,"originaltext":"最佳拟合无论分配和回收，均需查找链表，因此最费时间。","page":207,"position":{"x":3076,"y":9422},"textblocks":[{"first":[308.77313232421875,169.91696166992188,10.014007568359375,8.399993896484375],"last":[152.3889923095703,185.99697875976562,9.539993286132812,8.399993896484375],"length":27,"rects":[[308.77313232421875,169.91696166992188,140.19610595703125,8.399993896484375],[47.44900131225586,185.99697875976562,114.47998428344727,8.399993896484375]],"start":303,"text":"最佳拟合无论分配和回收，均需\n查找链表，因此最费时间。"}],"type":5,"uuid":"1022203e4706b104d4d88eb1034dd971"},{"content":"我感觉这个是不是最快的？","date":"2023-09-11 21:17:42","docid":1,"fillcolor":"ffffed99","id":239,"originaltext":"首次拟合在分配时需查询可利用空间表，而回收时仅需插人在表头即可","page":207,"textblocks":[{"first":[263.39202880859375,138.23696899414062,10.282989501953125,8.399993896484375],"last":[171.31500244140625,154.30697631835938,10.283004760742188,8.160003662109375],"length":32,"rects":[[263.39202880859375,138.23696899414062,185.09381103515625,8.399993896484375],[47.91899871826172,154.30697631835938,133.67900848388672,8.160003662109375]],"start":218,"text":"首次拟合在分配时需查询可利用空间表，\n而回收时仅需插人在表头即可"}],"type":5,"uuid":"2bc895ec4797c45bfa4c6d3a9b84390a"},{"annotations":[{"content":"<body style=\" font-family:'Microsoft YaHei UI Light'; font-size:10pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"bookxnotepro://opennote/?nb={91f9d651-022e-4b7f-8ea3-fba77a42f6da}&amp;book=79eed11fdba87a28341a31cc2c858f93&amp;page=206&amp;x=220&amp;y=600&amp;id=228&amp;uuid=afed404eccfd063b4ec5cabcbc0dd440\"><span style=\" text-decoration: underline; color:#0000ff;\">过程</span></a></p></body>","style":0}],"content":"分配时也是需要查找的，因为分配完了之后，还要把剩余的部分插入到合适位置","date":"2023-09-11 21:17:54","docid":1,"fillcolor":"ffffed99","id":240,"originaltext":"最差拟合恰相反，分配时无需查询链表，而回收时为将新的“空闲块＂插人在链表中适当的位置上，需先进行查找","page":207,"textblocks":[{"first":[191.88101196289062,154.30697631835938,10.283004760742188,8.160003662109375],"last":[288.7451171875,169.91696166992188,10.014007568359375,8.399993896484375],"length":51,"rects":[[191.88101196289062,154.30697631835938,257.0748291015625,8.160003662109375],[48.409000396728516,169.91696166992188,250.35012435913086,8.399993896484375]],"start":251,"text":"最差拟合恰相反，分配时无需查询链表，而回收时为将新\n的“空闲块＂插人在链表中适当的位置上，需先进行查找"}],"type":5,"uuid":"6dfc12fe45fe07b946fcf7047c89095c"}],"page":-1,"title":"时间对比","type":7,"uuid":"0a55b22ec1171bcef101eaeb0db22379"},{"date":"2023-09-11 21:20:54","docid":1,"fillcolor":"ffffed99","id":241,"originaltext":"因此，不同的情景需采用不同的方法，通常在选择时需考虑下列因素：用户的逻辑要求；请求分配量的大小分布；分配和释放的频率以及效率对系统的重要性等等","page":207,"textblocks":[{"first":[69.27899932861328,202.06698608398438,10.254997253417969,8.399993896484375],"last":[380.5508728027344,217.9169921875,10.093994140625,8.399993896484375],"length":72,"rects":[[69.27899932861328,202.06698608398438,379.43514251708984,8.399993896484375],[47.44900131225586,217.9169921875,343.1958656311035,8.399993896484375]],"start":331,"text":"因此，不同的情景需采用不同的方法，通常在选择时需考虑下列因素：用户的逻辑要\n求；请求分配量的大小分布；分配和释放的频率以及效率对系统的重要性等等"}],"type":5,"uuid":"4c850f1153f4b7bda92e70c7139cff50"},{"date":"2023-09-11 21:21:37","docid":1,"fillcolor":"ffffed99","id":242,"markups":[{"date":"2023-09-11 21:23:02","docid":1,"fillcolor":"ffffed99","id":243,"originaltext":"在回收空闲块时，首先应检查地址与它相邻的内存是否是空闲块","page":207,"textblocks":[{"first":[406.0732421875,297.35699462890625,10.541015625,8.399993896484375],"last":[290.362060546875,313.1869812011719,10.541015625,8.8800048828125],"length":29,"rects":[[406.0732421875,297.35699462890625,42.1640625,8.399993896484375],[47.91899871826172,313.1869812011719,252.98407745361328,8.8800048828125]],"start":596,"text":"在回收空\n闲块时，首先应检查地址与它相邻的内存是否是空闲块"}],"type":5,"uuid":"f973825a1b23aaefb817aa584e90ee1a"}],"originaltext":"在实际使用的系统中回收空闲块时还需考虑一个“结点合并＂的问题","page":207,"textblocks":[{"first":[68.55899810791016,233.75697326660156,10.280998229980469,8.639999389648438],"last":[366.7081298828125,233.75697326660156,10.281005859375,8.639999389648438],"length":30,"rects":[[68.55899810791016,233.75697326660156,308.43013763427734,8.639999389648438]],"start":405,"text":"在实际使用的系统中回收空闲块时还需考虑一个“结点合并＂的问题"}],"title":"一大块连续的内容被切成了一个个小块","type":5,"uuid":"5929f10c761701e762102d90e9cf20dc"}],"page":-1,"title":"三种方法的比较","type":7,"uuid":"bccc6961def1b4fb5d55a25829d44f62"}],"originaltext":"若可利用空间表中有若干个不小于n的空闲块","page":205,"textblocks":[{"first":[201.62901306152344,528.2269287109375,10.345001220703125,8.4000244140625],"last":[398.8891296386719,528.2269287109375,9.786712646484375,8.4000244140625],"length":20,"rects":[[201.62901306152344,528.2269287109375,207.0468292236328,8.4000244140625]],"start":508,"text":"若可利用空间表中有若干个不小于n的空闲块"}],"title":"没有足够大的块了","type":5,"uuid":"b86b91971988f5cd8f6b0271889c8384"}],"originaltext":"一块大小为m~n的空闲块，则只需将其中大小为n的一部分分配给申请分配的用户，同时将剩余大小为m—n的部分作为一个结点留在链表中即可。","page":205,"textblocks":[{"first":[284.77301025390625,496.5469970703125,10.180999755859375,8.8800048828125],"last":[160.24900817871094,528.2269287109375,10.345001220703125,8.4000244140625],"length":68,"rects":[[284.77301025390625,496.5469970703125,172.59609985351562,8.8800048828125],[57.04899978637695,512.626953125,400.08002853393555,8.6400146484375],[56.79899978637695,528.2269287109375,113.79500961303711,8.4000244140625]],"start":437,"text":"一块大小为m~n的空闲块，则只需将\n其中大小为n的一部分分配给申请分配的用户，同时将剩余大小为m—n的部分作为一\n个结点留在链表中即可。"}],"title":"拆大补小","type":5,"uuid":"231a1b6982f23c6393cdd97193445a08"}],"originaltext":"如何分配","page":205,"textblocks":[{"first":[352.4570007324219,480.95697021484375,10.51300048828125,8.6400146484375],"last":[383.9960021972656,480.95697021484375,10.51300048828125,8.6400146484375],"length":4,"rects":[[352.4570007324219,480.95697021484375,42.052001953125,8.6400146484375]],"start":404,"text":"如何分配"}],"type":5,"uuid":"d365dff229e404132adcd5d1f459b3df"}],"page":-1,"title":"分配","type":7,"uuid":"1834cabb592c9fd6dee04a26cf4ec038"}],"originaltext":"系统在运行期间分配给用户的内存块的大小不固定，可以随请求而变","page":204,"textblocks":[{"first":[105.6693115234375,597.4449462890625,10.261703491210938,8.6600341796875],"last":[402.7742004394531,597.4449462890625,10.261688232421875,8.6600341796875],"length":30,"rects":[[105.6693115234375,597.4449462890625,307.3665771484375,8.6600341796875]],"start":1214,"text":"系统在运行期间分配给用户的内存块的大小不固定，可以随请求而变"}],"type":5,"uuid":"0b84bda95d9652a54a48a09ab6ac2b97"}],"page":-1,"title":"三种结构形式","type":7,"uuid":"3893c89568c42a2472820f5e4db2045d"}],"page":203,"rect":[125.69999625384818,446.69998668730295,386.399988484383,555.8999834328895],"title":"“存储池”","type":2,"uuid":"ce8bf451a3b8da22344f7cc1bcf26097"}],"originaltext":"同时，每当新的用户请求分配内存时，系统需要巡视整个内存区中所有空闲块，并从中找出一个“合适＂的空闲块分配之。由此，系统需建立一张记录所有空闲块的”可利用空间表“，此表的结构可以是“目录表”，也可以是＂链表”。","page":203,"textblocks":[{"first":[151.97097778320312,261.8269958496094,10.227996826171875,8.399993896484375],"last":[367.2300720214844,293.0369873046875,9.326690673828125,8.399993896484375],"length":106,"rects":[[151.97097778320312,261.8269958496094,306.83990478515625,8.399993896484375],[59.44900131225586,277.4269714355469,398.87973403930664,8.6400146484375],[59.44900131225586,293.0369873046875,317.10776138305664,8.399993896484375]],"start":288,"text":"同时，每当新的用户请求分配内存时，系统需要巡视整个内存区中所\n有空闲块，并从中找出一个“合适＂的空闲块分配之。由此，系统需建立一张记录所有空闲\n块的”可利用空间表“，此表的结构可以是“目录表”，也可以是＂链表”。"}],"title":"可利用空间表","type":5,"uuid":"bf8f80de50af68a8b7f2b78346901d0e"}],"page":-1,"title":"可利用空间表及分配方法","type":7,"uuid":"f3d223ec244ed7b730c6d36bb8e09df0"},{"date":"2023-09-11 10:22:39","id":105,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:22:52","id":106,"linecolor":"ff59c6ff","page":-1,"title":"可利用空间表的结构","type":7,"uuid":"5873e97e09442614db84a6e7056ca4f7"},{"date":"2023-09-11 10:23:03","id":107,"linecolor":"ff59c6ff","page":-1,"title":"分配算法","type":7,"uuid":"2851d8167bb0fadcbe1be88a6249d7c4"},{"date":"2023-09-11 10:23:07","id":108,"linecolor":"ff59c6ff","page":-1,"title":"回收算法","type":7,"uuid":"7ef43a03d78549e3aff9e0b0e11bde6b"}],"page":-1,"title":"边界标识法","type":7,"uuid":"151bba52db796e6f0373768bd67225dc"},{"date":"2023-09-11 10:23:13","id":109,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:23:17","id":110,"linecolor":"ff59c6ff","page":-1,"title":"可利用空间表的结构","type":7,"uuid":"b837fda6623655bdc0c008314c6e97c1"},{"date":"2023-09-11 10:23:30","id":111,"linecolor":"ff59c6ff","page":-1,"title":"分配算法","type":7,"uuid":"6a7e63451b3548081c4ea1e2cdedec79"},{"date":"2023-09-11 10:23:35","id":112,"linecolor":"ff59c6ff","page":-1,"title":"回收算法","type":7,"uuid":"0935e2beffe90dab44cd66c361c08828"}],"page":-1,"title":"伙伴系统","type":7,"uuid":"3d38a03d05359bc7ac0fbf8c455a873c"},{"date":"2023-09-11 10:23:48","id":113,"linecolor":"ff59c6ff","page":-1,"title":"无用单元收集","type":7,"uuid":"04ea4c30aaae7a7b26b3b6ab7362863e"},{"date":"2023-09-11 10:24:39","id":114,"linecolor":"ff59c6ff","page":-1,"title":"存储紧缩","type":7,"uuid":"7b5aa9bab0c39521243d71867e02d81b"}],"page":-1,"title":"动态存储管理","type":7,"uuid":"95f771ce0411d593641127ce9547f5fe"},{"date":"2023-09-11 10:24:46","folded":false,"id":115,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:24:50","id":116,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:25:06","id":118,"linecolor":"ff59c6ff","page":-1,"title":"顺序表的查找","type":7,"uuid":"300d120ddb8d2929233b35d25852cddc"},{"date":"2023-09-11 10:25:12","id":119,"linecolor":"ff59c6ff","page":-1,"title":"有序表的查找","type":7,"uuid":"1a928844bc48a6a3ade9bc4d36427404"},{"date":"2023-09-11 10:25:19","id":120,"linecolor":"ff59c6ff","page":-1,"title":"静态树表的查找","type":7,"uuid":"c92fbebfe6ef4528f8fb875398b0c2aa"},{"date":"2023-09-11 10:25:28","id":121,"linecolor":"ff59c6ff","page":-1,"title":"索引顺序表的查找","type":7,"uuid":"fc6d3f58a1072ad175bca40003394116"}],"page":-1,"title":"静态查找表","type":7,"uuid":"4a732e90a04a1cacbcd19f516e3cdf03"},{"date":"2023-09-11 10:24:56","id":117,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:25:57","id":122,"linecolor":"ff59c6ff","page":-1,"title":"二叉排序树和平衡二叉树","type":7,"uuid":"156c2ed547090c8ea65fc6e28ee07c80"},{"content":"809笔记没讲B+树","date":"2023-09-11 10:26:13","id":123,"linecolor":"ff59c6ff","page":-1,"title":"B树和B+树","type":7,"uuid":"5fb2782e222c99ca15421445b65cedeb"},{"date":"2023-09-11 10:26:28","id":124,"linecolor":"fff89e02","page":-1,"title":"键树","type":7,"uuid":"b48b78f21233621d01d1389b9dde83a8"}],"page":-1,"title":"动态查找表","type":7,"uuid":"aac5241381435da6eb70140460ebd80f"},{"date":"2023-09-11 10:26:44","id":125,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:26:50","id":126,"linecolor":"ff59c6ff","page":-1,"title":"什么是哈希表","type":7,"uuid":"40c520885e730f86fa25788a9be273db"},{"date":"2023-09-11 10:26:55","id":127,"linecolor":"ff59c6ff","page":-1,"title":"哈希函数的构造函数","type":7,"uuid":"95b4f0a5fc7bb991897568a6e9e53fc3"},{"date":"2023-09-11 10:27:04","id":128,"linecolor":"ff59c6ff","page":-1,"title":"处理冲突的方法","type":7,"uuid":"1d402dc7308d79794c73c66fc2c8675c"},{"date":"2023-09-11 10:27:14","id":129,"linecolor":"ff59c6ff","page":-1,"title":"哈希表的查找及其分析","type":7,"uuid":"2f9d9a8ced2bd4d3e136f902352338fe"}],"page":-1,"title":"哈希表","type":7,"uuid":"8bbb04fc6d95d22793a1efb16321be73"}],"page":-1,"title":"查找","type":7,"uuid":"5068307b4ce2f8ebd2d9f3b44962cbe5"},{"date":"2023-09-11 10:27:52","folded":false,"id":130,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:27:57","id":131,"linecolor":"ff59c6ff","page":-1,"title":"概述","type":7,"uuid":"402e59bbc08fe38799b49f615bb6c596"},{"date":"2023-09-11 10:28:01","id":132,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:28:07","id":133,"linecolor":"ff59c6ff","page":-1,"title":"直接插入排序","type":7,"uuid":"a6613dd97f262047c281000974d646b5"},{"date":"2023-09-11 10:28:17","id":134,"linecolor":"ff59c6ff","page":-1,"title":"其他插入排序","type":7,"uuid":"a8271feba8320543e47c5b5a5bddcbd9"},{"date":"2023-09-11 10:28:24","id":135,"linecolor":"ff59c6ff","page":-1,"title":"希尔排序","type":7,"uuid":"cb332c0a5ce444bed5351493652d1fdf"}],"page":-1,"title":"插入排序","type":7,"uuid":"181949957886e5f8fa2b4d4e46ddd364"},{"date":"2023-09-11 10:28:31","id":136,"linecolor":"ff59c6ff","page":-1,"title":"快速排序","type":7,"uuid":"b9a8c1fb29de3aab488041b9681942a5"},{"date":"2023-09-11 10:28:35","id":137,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:28:39","id":138,"linecolor":"ff59c6ff","page":-1,"title":"简单选择排序","type":7,"uuid":"b9da5d1fc18961d633fe7b3e2a588bd5"},{"content":"这个不确定，可能有","date":"2023-09-11 10:28:44","id":139,"linecolor":"ff59c6ff","page":-1,"title":"树形选择排序","type":7,"uuid":"c7ab5b5a8d852a9951ee5b97dc6c4da9"},{"date":"2023-09-11 10:28:53","id":140,"linecolor":"ff59c6ff","page":-1,"title":"堆排序","type":7,"uuid":"296e00dfa2d7a83a95d90ba0264e909c"}],"page":-1,"title":"选择排序","type":7,"uuid":"9d426b016b3468ea9bf9a1c3fab413f2"},{"date":"2023-09-11 10:29:00","id":141,"linecolor":"ff59c6ff","page":-1,"title":"归并排序","type":7,"uuid":"d1d5c790665b3da3acf5ee9063b0dc4f"},{"date":"2023-09-11 10:29:18","id":143,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:29:24","id":144,"linecolor":"ff59c6ff","page":-1,"title":"多关键词的排序","type":7,"uuid":"09dde63141653e9251e131278de3159c"},{"date":"2023-09-11 10:29:37","id":145,"linecolor":"ff59c6ff","page":-1,"title":"链式基数排序","type":7,"uuid":"fb7a492ea76ac46c03d275ea46af52a1"}],"page":-1,"title":"基数排序","type":7,"uuid":"01d8b405d63e0e9b823fd22def4dead8"},{"date":"2023-09-11 10:29:47","id":146,"linecolor":"ff59c6ff","page":-1,"title":"各种内部排序方法的比较讨论","type":7,"uuid":"b9a95dc1ff27a0837dd506e026a99008"}],"page":-1,"title":"内部排序","type":7,"uuid":"cacb272fdc45e4e5de05c4344ab36ee3"},{"date":"2023-09-11 10:30:21","folded":false,"id":147,"linecolor":"fff89e02","markups":[{"date":"2023-09-11 10:30:27","id":148,"linecolor":"ff59c6ff","page":-1,"title":"外存信息的存取","type":7,"uuid":"790ee9621cd3fa6620e91f7e42f2e7c3"},{"date":"2023-09-11 10:30:41","id":149,"linecolor":"ff59c6ff","page":-1,"title":"外部排序的方法","type":7,"uuid":"469763c5cf9679a7574724e931accada"},{"date":"2023-09-11 10:30:49","id":150,"linecolor":"ff59c6ff","page":-1,"title":"多路平衡归并的实现","type":7,"uuid":"4ab102733b01ad19b8aaf5b0fca8cf21"},{"date":"2023-09-11 10:30:59","id":151,"linecolor":"ff59c6ff","page":-1,"title":"置换一选择排序","type":7,"uuid":"82a122620236ec0b3c88b7dbc074f3ee"},{"date":"2023-09-11 10:31:07","id":152,"linecolor":"ff59c6ff","page":-1,"title":"最佳归并树","type":7,"uuid":"8e68b9240881d35d270f304d6a148610"}],"page":-1,"title":"外部排序","type":7,"uuid":"8c8ae15ba1726bd28ed8ca7c3c026959"},{"date":"2023-09-11 10:31:15","folded":false,"id":153,"linecolor":"fff89e02","markups":[{"date":"2023-09-11 10:31:18","id":154,"linecolor":"ff59c6ff","page":-1,"title":"有关文件的基本概念","type":7,"uuid":"c439eb51c0d2e62d66eb9848947afbce"},{"date":"2023-09-11 10:31:47","id":155,"linecolor":"ff59c6ff","page":-1,"title":"顺序文件","type":7,"uuid":"adef3961f539b8ac1897f4553707877b"},{"date":"2023-09-11 10:31:52","id":156,"linecolor":"ff59c6ff","page":-1,"title":"索引文件","type":7,"uuid":"ab2751855ea41ec0c6d73f1ae8b7a026"},{"date":"2023-09-11 10:31:58","folded":false,"id":157,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:32:25","id":158,"linecolor":"ff59c6ff","page":-1,"title":"ISAM文件","type":7,"uuid":"4adfcfaff050d2a200935cf9e2e4c9f8"},{"date":"2023-09-11 10:32:39","id":159,"linecolor":"ff59c6ff","page":-1,"title":"VSAM文件","type":7,"uuid":"efa27508bfc6dfb71b070975d3d26986"}],"page":-1,"title":"ISAM文件和VSAM文件","type":7,"uuid":"5745c6c89d2b74897589db8184270226"},{"date":"2023-09-11 10:33:16","id":160,"linecolor":"ff59c6ff","page":-1,"title":"直接存取文件（散列文件）","type":7,"uuid":"efc8cc838f693810e5a0893e4a00b3dd"},{"date":"2023-09-11 10:33:28","id":161,"linecolor":"ff59c6ff","markups":[{"date":"2023-09-11 10:33:45","id":163,"linecolor":"ff59c6ff","page":-1,"title":"多重表文件","type":7,"uuid":"cb9d01fb38730307cd75d4e05d497321"},{"date":"2023-09-11 10:34:06","id":164,"linecolor":"ff59c6ff","page":-1,"title":"倒排文件","type":7,"uuid":"61b0a8b063617803aff7b7116c4cabc7"}],"page":-1,"title":"多关键字文件","type":7,"uuid":"04f6a5a64130912779dea0a73cee683c"}],"page":-1,"title":"文件","type":7,"uuid":"5fc11a8cf98e725dd28a48b7c1c77522"}],"maxid":243,"notelinks":[],"scalingratio":145,"summaries":[],"title":"严书内容","unimportant":[]}